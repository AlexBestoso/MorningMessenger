example of trusted key file. Everything must be encrypted with the exception of the uid and the public key location. 
As these two things will be used to place store the message properly. When you login properly, the names and contact info will be cached in memory.
<root>
	<uid>UNIQUE-ID-OF-TRUSTED-PERSON</uid>
	<pubkey>/location/of/public/key.pem</pubkey>
	<alias>Name of your Friend</alias>
	<remoteserverhost>yourFriendsDomain.onion</remoteserverhost>
	<remoteserverport>21345(default)</remoteserverport>
</root>

Example of message file. The entire message will be crafted by the client. the message data will be encrypted. Then the rest of the message will be encrypted as well
to prevent manipulation of the self destruct bit.
<root>
	<recptdate>date and time</recptdate>
	<messagedata>ENCRYPTED DATA<messagedata>
	<selfdestruct>(0 or 1)</selfdesctruct>
	
</root>

Current plan for setting up the server code. 
1) run launch server command, 
2) check if a lock file exists. If it does, don't launch the server and throw error message.
3) write lock file and then fork the process.
4) return parent to main menu.
5) using child process, launch the server and begin handling connections and messages.

Current plan for setting up the client code.
1) run connect server command.
2) select for a list of trusted keys the target server, or enter a custom server. 
3) for trusted servers, just beging the communications protocol. 
4) for untrusted servers, begin a key exchange process where server key will be given to you, and your key provided to server.
5) the keys provided to the servers will be placed into an untrusted key folder on the server.
6) after server master marks keys as trusted, communications will be enabled and messages sent. 
7) server master should also have the option to configure the system to allow for automated key trusting. 
