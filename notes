example of trusted key file. Everything must be encrypted with the exception of the uid and the public key location. 
As these two things will be used to place store the message properly. When you login properly, the names and contact info will be cached in memory.
<root>
	<uid>UNIQUE-ID-OF-TRUSTED-PERSON</uid>
	<pubkey>/location/of/public/key.pem</pubkey>
	<alias>Name of your Friend</alias>
	<remoteserverhost>yourFriendsDomain.onion</remoteserverhost>
	<remoteserverport>21345(default)</remoteserverport>
</root>

Example of message file. The entire message will be crafted by the client. the message data will be encrypted. Then the rest of the message will be encrypted as well
to prevent manipulation of the self destruct bit.
<root>
	<recptdate>date and time</recptdate>
	<messagedata>ENCRYPTED DATA<messagedata>
	<selfdestruct>(0 or 1)</selfdesctruct>
	
</root>


Server Communication Protocol: 

if new here
+	wait for client's public key.
+	try to load public key.
+	if failed, close connection and exit.
+	send server public key.
	Ask client what their name is
	Ask the client if they have any messages
	Tell client; Thank you for your business. The Server Master will be notified and will review your request for trust.
	Store public key and end user's name in a file within the untrusted key store.
else if already here
	wait for client's public key and take hash of it upon recipt.
	if key isn't trysted, close connection and exit.
	send client server public key. (Client side will also be able to validate server key)
	if leave a message
		wait for message
		tell user if recpt was successful or not.
		close connection.
	else if stream chat
		server generates two AES CTR keys and IVs.
		server sends key pair to client.
		Server then creates a AF_UNIX server forked.
			socket in is routed to AF_UNIX server out.
			AF_UNIX server in is routerd to socket out.
		server master can then see that there's an active chat and join it at will.
	 
else
	close connection. They a bad guy.
	
